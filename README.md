# Theatre-project
an e-business: a new ticket block booking system that involves ticketbrokers and theaters(or shows). The system consists of multiple ticketbrokers(clients) and multiple theaters(servers). The ticketbrokers can buy in quantity (block) of ticketsfrom the theaters with lower prices, and then resell the tickets to their customers with competitive prices. 


**Theatre:** Theater1 through TheaterK* are the objects of the same class on the server side: Each object has a method to be started as a thread by the Main method and will perform a number  of  functions.  It uses  a  PricingModel  to  determine  the ticket prices. It defines a  price-cut  event that can emit  an  event and  call  the  event handlers  in  the TicketBroker if  there  is  a  price-cut according  to  the  PricingModel. It  receives  the  orders from  the MultiCellBuffer.  For each  order,  you must start  a  new  thread  (resulting  in  multiple  threads  for processing  multiple  orders)  from OrderProcessing  class   to  process  the  order  based  on  the current price. There is a counter tin the Theater. After t(e.g., t= 20) price cuts have been made, a Theater thread will terminate. The ticketbrokers do not have to make an order after each price cut.

**PricingModel:** It can be a class or a method in the Theater class. It decides the price of tickets, which must be between 40and 200. It can increase or decrease the price. You must define a mathematical model(formula).  The  model  can  be  a  simple  random  function  for individual  projects.

**OrderProcessing:** A class or a method in a class on the server’s side. Whenever an order needs to be processed, a new thread is instantiated from this class (or method) to process the order. It will check the validity of the credit card number. You can define your credit card format, for example, the credit card number from the ticketbrokers must be a number registered to the Theater, or a number between two given numbers (e.g., between 5000 and 7000). For  the  three-member team project,  a  bank  service  must  be  created. Each OrderProcessingthread will calculate the total amount of charge, e.g., unitPrice*NoOfTickets + Tax + LocationCharge

**TicketBroker:** TicketBroker1through TicketBrokerN. You must use a variable N, but you can set N = 5 in your implementation. Each ticketbroker is a thread instantiated from the same class (or the same method in a class). The ticketbroker’s actions are event driven. Each ticketbroker contains a callback method (event handler) for the theaters to call when a price-cut event occurs. The ticketbroker will calculate the number of tickets to order, for example, based on the need and the difference between the previous price and the current price. The thread will terminate after the Theater threads have terminated. Each order is an OrderClass object. Then, the ticketbroker will send the order to the MultiCellBuffer.

**MultiCellBuffer:** A class or a struct that is used for the communication between the ticketbrokers(clients) and the theaters(servers): This class has N data cells. Each cell is a reference to an OrderClass object. The number of cells available must be less than (<) the max number of ticketbrokers in your experiment. To write data into and to read data from one of the available cells, setOneCell and getOneCell methods can be defined. You must use a semaphore of value n to manage the availability of the cells. You must use an additional lock mechanism to provide read or write permissions for a cell. This lock mechanism can be one of the mechanisms offered through a library function, or a mechanism that you define by yourself. A cell can be used as long as itis free (available). You cannot use a queue for the buffer, which is a different data structure. The semaphore allows a ticketbroker to see the availability of the cells, while the lock mechanism allows a ticketbroker to gain the right to write into one of the buffer cells. The Theater can read buffer cells at the same time. To ensure the thread safety, synchronization through lock or monitor is required for read/write and write/write overlap

**Main:** The Main thread will perform necessary preparation, create the buffer classes, instantiate the objects, create threads, and start threads. 
